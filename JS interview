1.  closure in JavaScript is when a function "remembers" its lexical scope even when the function is executed outside that lexical scope.
            --A closure is a function that remembers the environment (variables) in which it was created, even after that environment has gone.

            Here's a breakdown in simpler terms:

     - Lexical Scope: This refers to where variables and functions are defined in your code.

     - Closure Example: Imagine you have a function defined inside another function. The inner function has access to its own scope (variables it declares),
      the scope of the outer function, and also the global scope.

     - Memory of Scope: Even after the outer function finishes executing, the inner function still retains access to the variables and parameters of the outer function. This is closure in action – the inner 
        function "closes over" the scope it was created in.

     - Practical Use:
            * Encapsulation: They allow private variables and functions. You can create variables that are not accessible from the outside scope but are used within your functions.
            * Maintaining State: Closures can be used to remember the state of a function.
            * Callbacks and Asynchronous Code: Closures are commonly used in callback functions and event handlers.

2. Scope :- Scope in JavaScript refers to the visibility and accessibility of variables and functions within your code. 
    -Types of Scope:
            * Global Scope: Variables declared outside of any function or block have global scope. They can be accessed from anywhere within your JavaScript code.
            * Local Scope (Function Scope): Variables declared within a function are only accessible within that function. They have local scope.
            * Block Scope (Introduced with ES6): Variables declared with let and const have block scope, meaning they are only accessible within the block ({}) where they are defined.
            * Scope Chain:JavaScript uses lexical scoping, which means it determines the scope of variables based on their position within the code. When you try to access a variable, JavaScript will look for 
               it in the current scope and then move outward until it finds the variable or reaches the global scope.
3. callback function:-  in JavaScript is simply a function that is passed as an argument to another function and is executed after some operation has been completed. Here's a straightforward explanation:
4. Promises:-  in JavaScript are a way to handle asynchronous operations more easily and cleanly. Here’s a simple explanation:
        - What is a Promise?: A promise is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value.
        - States of a Promise:
                       1. Pending: Initial state, neither fulfilled nor rejected.
                       2. Fulfilled: The operation completed successfully.
                       3. Rejected: The operation failed.
5.Handling promises :
            -Handling multiple promises in JavaScript can be done easily and efficiently using Promise.all, Promise.race, Promise.allSettled, 
              and Promise.any. Here's a simple guide on how to use these methods:
            1. Promise.all
                        Promise.all is used when you need to wait for multiple promises to complete, and you want to handle their results together. If any of the promises reject, Promise.all will immediately
                        reject with the reason of the first promise that rejected.
            2.Promise.race
                        Promise.race returns a promise that resolves or rejects as soon as one of the promises in the array resolves or rejects.
            3.Promise.allSettled
                        Promise.allSettled waits for all the promises to settle (either resolve or reject), and returns an array of objects describing the outcome of each promise.
            4. Promise.any 
                        Promise.any takes an iterable of Promise objects and returns a single Promise that resolves as soon as any of the promises in the iterable resolves. If no promises in the iterable resolve 
                        (if all of the given promises are rejected), then the returned promise is rejected with an AggregateError.
      ----Summary
            Promise.all: Waits for all promises to resolve or any to reject.
            Promise.race: Waits for the first promise to resolve or reject.
            Promise.allSettled: Waits for all promises to settle, regardless of their outcome.
            Promise.any: Waits for the first promise to resolve (ignores rejections until all promises are rejected).
6.Async and Await :
             async and await are modern JavaScript features that make working with asynchronous code more readable and easier to manage. They are built on top of Promises.
     - What is async?
            The async keyword is used to declare a function as asynchronous. This means that the function will always return a Promise, even if it doesn't explicitly return one.
     - What is await?
            The await keyword can only be used inside an async function. It makes JavaScript wait until the Promise is resolved or rejected. This allows you to write asynchronous code as if it were synchronous.
     -  How Do They Work Together? 
            Using async and await together simplifies working with Promises and makes your code easier to read and maintain.

  **** Summary
          *  async: Declares an asynchronous function that returns a Promise.
          *  await: Pauses the execution of an async function and waits for the Promise to resolve or reject.
             Using async and await makes asynchronous code easier to write, read, and manage.
          * Error handling is straightforward with try...catch blocks.
   ------These features help you write cleaner and more intuitive asynchronous JavaScript code.
7. Spread and Rest Operator 
            -The spread and rest operators in JavaScript both use the ... syntax, but they serve different purposes based on how they are used. Here’s a simple explanation:
  **Spread Operator (...)
            The spread operator is used to spread the elements of an array or object into another array, object, or function arguments. It allows you to unpack elements from arrays or properties from objects.
      - Examples:
      1.Array Example:
            const numbers = [1, 2, 3];
            const moreNumbers = [...numbers, 4, 5, 6];
            console.log(moreNumbers); // Outputs: [1, 2, 3, 4, 5, 6]
          In this example, ...numbers spreads the elements of the numbers array into the moreNumbers array.
      2.Object Example
            const person = { name: 'Alice', age: 25 };
            const updatedPerson = { ...person, city: 'New York' };
            console.log(updatedPerson); // Outputs: { name: 'Alice', age: 25, city: 'New York' }
       3.Function argumanet
            console.log(add(...numbers)); // Outputs: 6
            In this example, ...numbers spreads the elements of the numbers array as arguments to the add function.
  **Rest Operator (...)
            The rest operator is used to collect multiple elements or properties into a single array or object. It is used in function parameters or destructuring assignments to group the remaining elements or 
            properties.
      --Examples:
            1. Function Parameters Example:
                                    function sum(...numbers) {
                                      return numbers.reduce((total, number) => total + number, 0);
                        }
                        console.log(sum(1, 2, 3, 4)); // Outputs: 10
                  ***//**In this example, ...numbers collects all the passed arguments into an array called numbers.
            2. Array Destructuring Example
                        const [first, ...rest] = [1, 2, 3, 4];
                        console.log(first); // Outputs: 1
                        console.log(rest);  // Outputs: [2, 3, 4]
            3. Object Destructuring Example:
  ***//**//**
             Summary
            Spread Operator (...): Expands the elements of an array or object into another array, object, or function arguments.
            Rest Operator (...): Collects multiple elements or properties into a single array or object.
            These operators make working with arrays, objects, and function arguments more flexible and concise in JavaScript.


8. Shallow copy and deep copy
            When you copy an object or array in JavaScript, you can create a shallow copy or a deep copy
       1.Shallow 
            A shallow copy of an object or array is a new object or array that contains references to the same elements as the original. This means that if the elements are objects themselves, the shallow copy             will still refer to the same nested objects as the original.
            Example :=== const shallowCopy = [...originalArray]; // or originalArray.slice()
                        const shallowCopy = { ...originalObject }; // or Object.assign({}, originalObject)
      2. Deep copy
            A deep copy of an object or array is a new object or array that is completely independent of the original. This means that even if the elements are objects themselves, the deep copy will have its own 
            copies of those nested objects.
         Example :- 
               const originalArray = [1, 2, { a: 3 }];
              const deepCopy = JSON.parse(JSON.stringify(originalArray));
   **//**//**  Summary
            Shallow Copy: Copies the top-level properties, but nested objects are shared between the original and the copy.
            Deep Copy: Creates a completely independent copy, including all nested objects.

9.  call, apply, and bind in JavaScript
            - In JavaScript, call, apply, and bind are methods that allow you to set the this context for a function. This can be particularly useful when you want a function to operate in the context of a 
              different object. Here’s a simple explanation of each: 
    1. Call Method
            The call method allows you to invoke a function with a specified this context and arguments passed individually.
           
            function greet(greeting, punctuation) {
                console.log(greeting + ', ' + this.name + punctuation);
            }

            const person = { name: 'Alice' };

            greet.call(person, 'Hello', '!'); // Outputs: Hello, Alice!
   2. apply Method
            The apply method is similar to call, but it accepts arguments as an array (or array-like object).

            Example:

            function greet(greeting, punctuation) {
                console.log(greeting + ', ' + this.name + punctuation);
            }

            const person = { name: 'Alice' };

            greet.apply(person, ['Hello', '!']); // Outputs: Hello, Alice!
  3. bind Method
            The bind method creates a new function that, when called, has its this keyword set to the specified value, with a given sequence of arguments preceding any provided when the new function is called.
            function greet(greeting, punctuation) {
                console.log(greeting + ', ' + this.name + punctuation);
            }            

            const person = { name: 'Alice' };

            const greetPerson = greet.bind(person);

            greetPerson('Hello', '!'); // Outputs: Hello, Alice!

   **//**/***
 Summary
     - call: Invokes a function with a specified this context and arguments passed individually.
              functionName.call(thisArg, arg1, arg2, ...)
     - apply: Invokes a function with a specified this context and arguments passed as an array.
            functionName.apply(thisArg, [arg1, arg2, ...])
     - bind: Creates a new function with a specified this context and optionally prepends arguments to it.
            const newFunction = functionName.bind(thisArg, arg1, arg2, ...)
  ***** These methods give you control over the this value within functions, enabling more flexible and reusable code.

