1.  closure in JavaScript is when a function "remembers" its lexical scope even when the function is executed outside that lexical scope.
            --A closure is a function that remembers the environment (variables) in which it was created, even after that environment has gone.

            Here's a breakdown in simpler terms:

     - Lexical Scope: This refers to where variables and functions are defined in your code.

     - Closure Example: Imagine you have a function defined inside another function. The inner function has access to its own scope (variables it declares),
      the scope of the outer function, and also the global scope.

     - Memory of Scope: Even after the outer function finishes executing, the inner function still retains access to the variables and parameters of the outer function. This is closure in action – the inner 
        function "closes over" the scope it was created in.

     - Practical Use:
            * Encapsulation: They allow private variables and functions. You can create variables that are not accessible from the outside scope but are used within your functions.
            * Maintaining State: Closures can be used to remember the state of a function.
            * Callbacks and Asynchronous Code: Closures are commonly used in callback functions and event handlers.

2. Scope :- Scope in JavaScript refers to the visibility and accessibility of variables and functions within your code. 
    -Types of Scope:
            * Global Scope: Variables declared outside of any function or block have global scope. They can be accessed from anywhere within your JavaScript code.
            * Local Scope (Function Scope): Variables declared within a function are only accessible within that function. They have local scope.
            * Block Scope (Introduced with ES6): Variables declared with let and const have block scope, meaning they are only accessible within the block ({}) where they are defined.
            * Scope Chain:JavaScript uses lexical scoping, which means it determines the scope of variables based on their position within the code. When you try to access a variable, JavaScript will look for 
               it in the current scope and then move outward until it finds the variable or reaches the global scope.
3. callback function:-  in JavaScript is simply a function that is passed as an argument to another function and is executed after some operation has been completed. Here's a straightforward explanation:
4. Promises:-  in JavaScript are a way to handle asynchronous operations more easily and cleanly. Here’s a simple explanation:
        - What is a Promise?: A promise is an object that represents the eventual completion or failure of an asynchronous operation and its resulting value.
        - States of a Promise:
                       1. Pending: Initial state, neither fulfilled nor rejected.
                       2. Fulfilled: The operation completed successfully.
                       3. Rejected: The operation failed.
5.Handling promises :
            -Handling multiple promises in JavaScript can be done easily and efficiently using Promise.all, Promise.race, Promise.allSettled, 
              and Promise.any. Here's a simple guide on how to use these methods:
            1. Promise.all
                        Promise.all is used when you need to wait for multiple promises to complete, and you want to handle their results together. If any of the promises reject, Promise.all will immediately
                        reject with the reason of the first promise that rejected.
            2.Promise.race
                        Promise.race returns a promise that resolves or rejects as soon as one of the promises in the array resolves or rejects.
            3.Promise.allSettled
                        Promise.allSettled waits for all the promises to settle (either resolve or reject), and returns an array of objects describing the outcome of each promise.
            4. Promise.any 
                        Promise.any takes an iterable of Promise objects and returns a single Promise that resolves as soon as any of the promises in the iterable resolves. If no promises in the iterable resolve 
                        (if all of the given promises are rejected), then the returned promise is rejected with an AggregateError.
      ----Summary
            Promise.all: Waits for all promises to resolve or any to reject.
            Promise.race: Waits for the first promise to resolve or reject.
            Promise.allSettled: Waits for all promises to settle, regardless of their outcome.
            Promise.any: Waits for the first promise to resolve (ignores rejections until all promises are rejected).

